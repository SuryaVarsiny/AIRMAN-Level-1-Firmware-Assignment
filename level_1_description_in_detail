1. Sensor Data Generation
Method Used: Simulated Data

Introduction:

Simulated sensor data was generated by combining deterministic motion patterns with controlled noise, ensuring realism while remaining predictable and easy to validate.

Pattern Types Used:

1️⃣ Sine / Cosine Functions
Used to model periodic and oscillatory motion, common in real physical systems.

2️⃣ Random Noise
Used to emulate sensor measurement noise, added as small bounded perturbations.

3️⃣ Linear / Predictable Motion Patterns
Used to represent steady motion or drift over time.

Sensor-wise Pattern Application:

> Accelerometer (ax, ay, az)
| Component | Pattern Used     | Description                              |
| --------- | ---------------- | ---------------------------------------- |
| ax        | Sine function    | Simulates lateral oscillatory motion     |
| ay        | Cosine function  | Phase-shifted motion relative to ax      |
| az        | Constant + noise | Represents gravity (≈9.81 m/s²)          |
| All axes  | Random noise     | Small zero-mean noise added to each axis |
Formulae Explanation:
ax = A * sin(ωt) + noise
ay = A * cos(ωt) + noise
az = g + noise
> Gyroscope (gx, gy, gz)
| Component | Pattern Used    | Description                |
| --------- | --------------- | -------------------------- |
| gx        | Sine function   | Smooth angular rotation    |
| gy        | Cosine function | Orthogonal angular motion  |
| gz        | Linear drift    | Slow constant angular rate |
| All axes  | Random noise    | Models sensor jitter       |
Formulae Explanation:
gx = B * sin(ωt) + noise
gy = B * cos(ωt) + noise
gz = drift_rate * t + noise
>Magnetometer (mx, my, mz)
| Component | Pattern Used    | Description                   |
| --------- | --------------- | ----------------------------- |
| mx        | Cosine function | Simulates heading variation   |
| my        | Sine function   | Orthogonal magnetic component |
| mz        | Constant        | Vertical magnetic field       |
| All axes  | Random noise    | Environmental disturbances    |
Formulae Explanation:
mx = M * cos(θ(t)) + noise
my = M * sin(θ(t)) + noise
mz = constant + noise
>Altitude
| Pattern Used  | Description                        |
| ------------- | ---------------------------------- |
| Linear motion | Simulates steady ascent or descent |
| Random noise  | Models barometric sensor noise     |
Formula Explanation:
altitude = alt_start + climb_rate * t + noise
>Temperature
| Pattern Used  | Description                              |
| ------------- | ---------------------------------------- |
| Sine function | Slow environmental temperature variation |
| Linear drift  | Gradual warming or cooling               |
| Random noise  | Sensor quantization noise                |
Formula Explanation:
temp = T_base + T_amp * sin(ωt) + drift * t + noise

Why These Patterns Were Chosen

Sine/cosine: Represent realistic oscillatory motion and rotation
Linear motion: Easy to validate and debug in logs
Random noise: Tests robustness of parsing and checksum logic
Combination approach: Closely approximates real sensor behavior while remaining deterministic

Program simulation using VSCODE+MSYS2 MINGW64 Using Python and c:

S1:Using Visual Studio Code and GCC (MSYS2 MinGW64), a C firmware program simulates IMU sensor data (accelerometer, gyroscope), altitude, and temperature using sine, cosine, and linear motion models.
S2:The firmware formats the simulated data into a UART-style telemetry frame and computes an XOR checksum to ensure data integrity.
S3:Telemetry frames are transmitted at 20 Hz via standard output, simulating UART communication without hardware.
S4:A Python 3 receiver script reads the telemetry stream, validates the checksum, and parses the CSV-formatted fields.
S5:Verified telemetry data is logged into a CSV file and printed in a readable format for monitoring and analysis.


Summary

Each simulated sensor value is generated using a combination of sine/cosine functions, linear motion, and random noise, ensuring that:
Motion is realistic
Behavior is predictable
Data integrity mechanisms can be tested effectively.This approach satisfies all Level 1 requirements while remaining simple, testable, and extensible.





